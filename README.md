# Сессия по информатике

## Теория
[Кликни по мне](https://docs.google.com/document/d/1rHIlts4m9fFG6pwYEDSwO7mt5GNAptcOIMF9kgQwyYM/edit?usp=sharing)

## Авторы
[Дмитрий Оконешников](https://github.com/MagicWinnie)  
[Максим Паньков](https://github.com/MaxSprog)  

## Задачи
1) [Кликни по мне](1.c)
```
Написать функцию delete_min, которая удаляет в дереве двоичного поиска минимальный элемент. В случае, если в дереве нет вершин, процедура должна возвращать NULL.

Гарантируется, что в дереве нет повторяющихся элементов.

struct Node * delete_min(struct Node * root);
```  
2) [Кликни по мне](2.cpp)
```
Написать функцию change_base, переводящую текстовое представление num неотрицательного числа из системы счисления b1 в систему b2. Цифры, большие 9, обозначить латинскими буквами А, В, С, ... . Основания систем счисления не больше 30. Например, при num = “1001011”, b1 = 2, b2 = 16 результатом должна быть строка “4B”.

char * change_base(char * num, int b1, int b2);
```
3) [Кликни по мне](3.c)
```
Дана строка, содержащая арифметическое выражение в обратной польской записи. Допустимы только бинарные операторы +, -, * и цифры 0, 1, … 9. Вычислить данное выражение при условии, что строка содержит не более N символов.

Например, для входа “1 2 + 4 × 3 +” функция должна вернуть 15.

#define N 1000
int compute_RPN(char * input);
```
4) [Кликни по мне](4.c)
```
Написать процедуру traverse, которая заполняет матрицу B[N][N] (слева-направо, сверху-вниз) элементами матрицы A[N][N], которая обходится по спирали.
#define N 1000
void traverse(double A[][], double B[][]);
```
5) [Кликни по мне](5.c)
```
Ориентированный граф задан матрицей смежности. Найти все вершины, в которые
есть путь из данной.

#define N 1000
int * reachable(int M[][], int A);
```
6) [Кликни по мне](6.c)
```
Дана строка, состоящая не более чем из N символов. Найти сумму квадратов цифр в данной строке. Например, для строки “f!q].5)6  0ty” функция должна вернуть 61.

#define N 1000
struct Node * sum_squared_digits(char * input);
```
7) [Кликни по мне](7.c)
```
Написать функцию longest_subseq, вычисляющую для данной последовательности A
положительных целых чисел, заданной массивом длины n, наиболее длинную
неубывающую подпоследовательность, возможно не подряд идущих элементов.
Результирующая последовательность завершается 0. Например, для
последовательности 1 4 8 2 3 6 3 9 2 4 правильным результатом будет 
1 2 3 3 4 0.

#define N 1000
int * longest_subseq(int A[]);
```
8) [Кликни по мне](8.c)
```
TODO
```
9) [Кликни по мне](9.c)
```
TODO
```
10) [Кликни по мне](10.c)
```
TODO
```
11) [Кликни по мне](11.c)
```
TODO
```
12) [Кликни по мне](12.c)
```
TODO
```
13) [Кликни по мне](13.c)
```
TODO
```
14) [Кликни по мне](14.c)
```
Реализовать функцию Аккермана с помощью рекурсии:
            Ack(0, m) = m + 1
            Ack(n, 0) = Ack(n - 1, 1)
            Ack(n, m) = Ack(n - 1, Ack(n, m - 1))
где n, m > 0.

Систематически преобразовать в итеративный вариант.

long Ack(long n, long m);
```
15) [Кликни по мне](15.c)
```
TODO
```
16) [Кликни по мне](16.c)
```
TODO
```