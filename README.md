# Сессия по информатике

## Теория
[Кликни по мне](https://docs.google.com/document/d/1rHIlts4m9fFG6pwYEDSwO7mt5GNAptcOIMF9kgQwyYM/edit?usp=sharing)

## Авторы
[Дмитрий Оконешников](https://github.com/MagicWinnie)  
[Максим Паньков](https://github.com/MaxSprog)  

## Задачи
1) [Кликни по мне](1.c)
```
Написать функцию delete_min, которая удаляет в дереве двоичного поиска минимальный элемент. В случае, если в дереве нет вершин, процедура должна возвращать NULL.

Гарантируется, что в дереве нет повторяющихся элементов.

struct Node * delete_min(struct Node * root);
```  
2) [Кликни по мне](2.cpp)
```
Написать функцию change_base, переводящую текстовое представление num неотрицательного числа из системы счисления b1 в систему b2. Цифры, большие 9, обозначить латинскими буквами А, В, С, ... . Основания систем счисления не больше 30. Например, при num = “1001011”, b1 = 2, b2 = 16 результатом должна быть строка “4B”.

char * change_base(char * num, int b1, int b2);
```
3) [Кликни по мне](3.c)
```
Дана строка, содержащая арифметическое выражение в обратной польской записи. Допустимы только бинарные операторы +, -, * и цифры 0, 1, … 9. Вычислить данное выражение при условии, что строка содержит не более N символов.

Например, для входа “1 2 + 4 × 3 +” функция должна вернуть 15.

#define N 1000
int compute_RPN(char * input);
```
4) [Кликни по мне](4.c)
```
Написать процедуру traverse, которая заполняет матрицу B[N][N] (слева-направо, сверху-вниз) элементами матрицы A[N][N], которая обходится по спирали.
#define N 1000
void traverse(double A[][], double B[][]);
```
5) [Кликни по мне](5.c)
```
Ориентированный граф задан матрицей смежности. Найти все вершины, в которые
есть путь из данной.

#define N 1000
int * reachable(int M[][], int A);
```
6) [Кликни по мне](6.c)
```
Дана строка, состоящая не более чем из N символов. Найти сумму квадратов цифр в данной строке. Например, для строки “f!q].5)6  0ty” функция должна вернуть 61.

#define N 1000
struct Node * sum_squared_digits(char * input);
```
7) [Кликни по мне](7.c)
```
Написать функцию longest_subseq, вычисляющую для данной последовательности A
положительных целых чисел, заданной массивом длины n, наиболее длинную
неубывающую подпоследовательность, возможно не подряд идущих элементов.
Результирующая последовательность завершается 0. Например, для
последовательности 1 4 8 2 3 6 3 9 2 4 правильным результатом будет 
1 2 3 3 4 0.

#define N 1000
int * longest_subseq(int A[]);
```
8) [Кликни по мне](8.c)
```
TODO
```
9) [Кликни по мне](9.c)
```
Написать функцию delete_element, которая удаляет в дереве двоичного поиска
элемент с заданным целочисленным ключом. В случае, если в дереве нет указанного
элемента, программа должна вернуть NULL, а дерево должно остаться неизменным.
После успешного завершения операции, структура данных должна остаться деревом
двоичного поиска. 

Гарантируется, что в дереве нет повторяющихся элементов.

struct STree * delete_element(struct STree * root, int element);
```
10) [Кликни по мне](10.c)
```
Написать процедуру simple_sum, печатающую все возможные разложения числа n в сумму различных простых слагаемых.

void simple_sum(int n);
```
11) [Кликни по мне](11.c)
```
Написать функцию next_perm поиска следующей по алфавиту перестановки,
например для 1 2 5 6 4 3 результатом должно быть 1 2 6 3 4 5. Процедура возвращает
истину, если следующая перестановка существует и сохраняет результат в массиве
A.

#define N 1000
#include <stdbool.h>
bool next_perm(double A[]);
```
12) [Кликни по мне](12.c)
```
Дано двоичное дерево Т, в вершинах которого записаны уникальные целые числа. Построить из вершин дерева Т новое двоичное дерево поиска. Дерево T должно остаться неизменным.

struct Node * convert_to_binary_search_tree(struct Node * root);
```
13) [Кликни по мне](13.c)
```
Проверить, сбалансированы ли скобки (, [, { в строке. Длина строки не превышает N.

#define N 1000
#include <stdbool.h>
bool is_balanced_brackets(char * input);
```
14) [Кликни по мне](14.c)
```
Реализовать функцию Аккермана с помощью рекурсии:
            Ack(0, m) = m + 1
            Ack(n, 0) = Ack(n - 1, 1)
            Ack(n, m) = Ack(n - 1, Ack(n, m - 1))
где n, m > 0.

Систематически преобразовать в итеративный вариант.

long Ack(long n, long m);
```
15) [Кликни по мне](15.c)
```
Написать процедуру rshift, выполняющую циклический сдвиг элементов массива A
длины N на k элементов вправо, не используя дополнительный массив. Например,
для массива 1 3 5 7 9 2 4 6 8 10 и сдвига 4, результатом должно быть 4 6 8 10 1 3 5 7 9 2.

#define N 1000
void rshift(double A[], int k);
```
16) [Кликни по мне](16.c)
```
Односвязный список задан указателем на первый элемент. Написать функцию, переставляющую элементы списка в обратном порядке с потреблением памяти O(1).
struct Node * reverse(struct Node * first);
```